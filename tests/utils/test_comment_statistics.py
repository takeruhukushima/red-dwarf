import pytest
from tests.fixtures import polis_convo_data
from tests.helpers import get_grouped_statement_ids
from pandas._testing import assert_dict_equal
from numpy.testing import assert_array_equal

from reddwarf.utils import stats, polismath, matrix, statements as stmnts
from tests.test_utils import make_vote_matrix
from tests import helpers
from reddwarf.data_loader import Loader
from reddwarf.types.polis import PolisRepness


def setup_test(fixture):
    loader = Loader(
        filepaths=[
            f"{fixture.data_dir}/votes.json",
            f"{fixture.data_dir}/comments.json",
            f"{fixture.data_dir}/conversation.json",
        ]
    )
    VOTES = loader.votes_data

    raw_vote_matrix = matrix.generate_raw_matrix(votes=VOTES)
    # We don't actuall need this outside PCA?
    # STATEMENTS = loader.comments_data
    # _, _, mod_out, _ = stmnts.process_statements(statement_data=STATEMENTS)
    # filtered_vote_matrix = matrix.simple_filter_matrix(
    #     vote_matrix=raw_vote_matrix,
    #     mod_out_statement_ids=mod_out,
    # )

    # Get list of all active participant ids, since Polis has some edge-cases
    # that keep specific participants, and we need to keep them from being filtered out.
    all_clustered_participant_ids, cluster_labels = (
        polismath.extract_data_from_polismath(fixture.math_data)
    )

    # Generate stats all groups and all statements.
    grouped_stats_df, gac_df = stats.calculate_comment_statistics_dataframes(
        vote_matrix=raw_vote_matrix.loc[all_clustered_participant_ids, :],
        cluster_labels=cluster_labels,
    )

    return grouped_stats_df, gac_df


@pytest.mark.parametrize(
    "polis_convo_data",
    ["small-no-meta", "small-with-meta", "medium-no-meta", "medium-with-meta"],
    indirect=True,
)
def test_select_representative_statements_real_data(polis_convo_data):
    fixture = polis_convo_data
    grouped_stats_df, _ = setup_test(fixture)

    polis_repness = stats.select_representative_statements(
        grouped_stats_df=grouped_stats_df,
        # Don't bother calculating this ourselves in test.
        mod_out_statement_ids=fixture.math_data["mod-out"],
        pick_max:Optional[int]=5,
    )

    calculated_repness: PolisRepness = polis_repness
    expected_repness: PolisRepness = fixture.math_data["repness"]
    # Compare the selected statements calculated from those generated by polismath.
    assert get_grouped_statement_ids(calculated_repness) == get_grouped_statement_ids(
        expected_repness
    )


@pytest.mark.parametrize(
    "polis_convo_data",
    ["small-no-meta", "small-with-meta", "medium-no-meta", "medium-with-meta"],
    indirect=True,
)
def test_calculate_comment_statistics_dataframes_grouped_stats_df_real_data(
    polis_convo_data,
):
    fixture = polis_convo_data
    grouped_stats_df, _ = setup_test(fixture)

    # Cycle through all the expected data calculated by Polis platform
    for group_id, statements in fixture.math_data["repness"].items():
        group_id = int(group_id)
        for st in statements:
            expected_repr = st["repness"]
            expected_repr_test = st["repness-test"]
            expected_prob = st["p-success"]
            expected_prob_test = st["p-test"]

            # Fetch matching calculated values for comparison.
            keys = ["prob", "prob_test", "repness", "repness_test"]
            if st["repful-for"] == "agree":
                key_map = dict(zip(keys, ["pa", "pat", "ra", "rat"]))
            else:  # disagree
                key_map = dict(zip(keys, ["pd", "pdt", "rd", "rdt"]))

            actual = {
                k: grouped_stats_df.loc[(group_id, st["tid"]), v]
                for k, v in key_map.items()
            }

            assert actual["prob"] == pytest.approx(expected_prob)
            assert actual["prob_test"] == pytest.approx(expected_prob_test)
            assert actual["repness"] == pytest.approx(expected_repr)
            assert actual["repness_test"] == pytest.approx(expected_repr_test)


@pytest.mark.parametrize(
    "polis_convo_data",
    ["small-no-meta", "small-with-meta", "medium-no-meta", "medium-with-meta"],
    indirect=True,
)
def test_calculate_comment_statistics_dataframes_gac_df_real_data(polis_convo_data):
    fixture = polis_convo_data
    _, gac_df = setup_test(fixture)

    calculated = helpers.simulate_api_response(gac_df["group-aware-consensus"].items())
    expected = fixture.math_data["group-aware-consensus"]
    assert_dict_equal(calculated, expected)


def test_calculate_comment_statistics_no_group_labels(make_vote_matrix):
    # Makes this matrix:
    # [
    #   [ 0,    1, None],
    #   [-1,    1,    1],
    #   [-1, None, None],
    # ]
    simple_vote_matrix = make_vote_matrix(id_type="int")

    N_g_c, N_v_g_c, *_ = stats.calculate_comment_statistics(
        vote_matrix=simple_vote_matrix
    )

    # When no group cluster labels supplied, calculate_comment_statistics()
    # internally applies a `0` label.
    MOCK_GROUP_ID = 0
    calculated_total_votes = N_g_c[MOCK_GROUP_ID,]
    calculated_agree_votes = N_v_g_c[stats.votes.A, MOCK_GROUP_ID, :]
    calculated_disagree_votes = N_v_g_c[stats.votes.D, MOCK_GROUP_ID, :]

    assert_array_equal(calculated_total_votes, [3, 2, 1])
    assert_array_equal(calculated_agree_votes, [0, 2, 1])
    assert_array_equal(calculated_disagree_votes, [2, 0, 0])
